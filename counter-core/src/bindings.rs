// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
pub mod exports {
    pub mod coffeeshop {
        pub mod counter {
            #[allow(clippy::all)]
            pub mod api {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Id = _rt::String;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum ItemType {
                    /// Beverages
                    Cappuccino,
                    CoffeeBlack,
                    CoffeeWithRoom,
                    Espresso,
                    EspressoDouble,
                    Latte,
                    /// Food
                    Cakepop,
                    Croissant,
                    Muffin,
                    CroissantChocolate,
                }
                impl ::core::fmt::Debug for ItemType {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            ItemType::Cappuccino => f.debug_tuple("ItemType::Cappuccino").finish(),
                            ItemType::CoffeeBlack => {
                                f.debug_tuple("ItemType::CoffeeBlack").finish()
                            }
                            ItemType::CoffeeWithRoom => {
                                f.debug_tuple("ItemType::CoffeeWithRoom").finish()
                            }
                            ItemType::Espresso => f.debug_tuple("ItemType::Espresso").finish(),
                            ItemType::EspressoDouble => {
                                f.debug_tuple("ItemType::EspressoDouble").finish()
                            }
                            ItemType::Latte => f.debug_tuple("ItemType::Latte").finish(),
                            ItemType::Cakepop => f.debug_tuple("ItemType::Cakepop").finish(),
                            ItemType::Croissant => f.debug_tuple("ItemType::Croissant").finish(),
                            ItemType::Muffin => f.debug_tuple("ItemType::Muffin").finish(),
                            ItemType::CroissantChocolate => {
                                f.debug_tuple("ItemType::CroissantChocolate").finish()
                            }
                        }
                    }
                }

                impl ItemType {
                    pub(crate) unsafe fn _lift(val: u8) -> ItemType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => ItemType::Cappuccino,
                            1 => ItemType::CoffeeBlack,
                            2 => ItemType::CoffeeWithRoom,
                            3 => ItemType::Espresso,
                            4 => ItemType::EspressoDouble,
                            5 => ItemType::Latte,
                            6 => ItemType::Cakepop,
                            7 => ItemType::Croissant,
                            8 => ItemType::Muffin,
                            9 => ItemType::CroissantChocolate,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct CommandItem {
                    pub item_type: ItemType,
                }
                impl ::core::fmt::Debug for CommandItem {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("CommandItem")
                            .field("item-type", &self.item_type)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum ItemStatus {
                    Placed,
                    InProgress,
                    Fulfilled,
                }
                impl ::core::fmt::Debug for ItemStatus {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            ItemStatus::Placed => f.debug_tuple("ItemStatus::Placed").finish(),
                            ItemStatus::InProgress => {
                                f.debug_tuple("ItemStatus::InProgress").finish()
                            }
                            ItemStatus::Fulfilled => {
                                f.debug_tuple("ItemStatus::Fulfilled").finish()
                            }
                        }
                    }
                }

                impl ItemStatus {
                    pub(crate) unsafe fn _lift(val: u8) -> ItemStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => ItemStatus::Placed,
                            1 => ItemStatus::InProgress,
                            2 => ItemStatus::Fulfilled,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[derive(Clone)]
                pub struct OrderItemLineDto {
                    pub item_line_id: Id,
                    pub item_type: ItemType,
                    pub item_status: ItemStatus,
                }
                impl ::core::fmt::Debug for OrderItemLineDto {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("OrderItemLineDto")
                            .field("item-line-id", &self.item_line_id)
                            .field("item-type", &self.item_type)
                            .field("item-status", &self.item_status)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum OrderSource {
                    Counter,
                    Web,
                }
                impl ::core::fmt::Debug for OrderSource {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            OrderSource::Counter => f.debug_tuple("OrderSource::Counter").finish(),
                            OrderSource::Web => f.debug_tuple("OrderSource::Web").finish(),
                        }
                    }
                }

                impl OrderSource {
                    pub(crate) unsafe fn _lift(val: u8) -> OrderSource {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => OrderSource::Counter,
                            1 => OrderSource::Web,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum OrderStatus {
                    Placed,
                    InProgress,
                    Fulfilled,
                }
                impl ::core::fmt::Debug for OrderStatus {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            OrderStatus::Placed => f.debug_tuple("OrderStatus::Placed").finish(),
                            OrderStatus::InProgress => {
                                f.debug_tuple("OrderStatus::InProgress").finish()
                            }
                            OrderStatus::Fulfilled => {
                                f.debug_tuple("OrderStatus::Fulfilled").finish()
                            }
                        }
                    }
                }

                impl OrderStatus {
                    pub(crate) unsafe fn _lift(val: u8) -> OrderStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => OrderStatus::Placed,
                            1 => OrderStatus::InProgress,
                            2 => OrderStatus::Fulfilled,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum Location {
                    Hochiminh,
                    Hanoi,
                    Danang,
                }
                impl ::core::fmt::Debug for Location {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Location::Hochiminh => f.debug_tuple("Location::Hochiminh").finish(),
                            Location::Hanoi => f.debug_tuple("Location::Hanoi").finish(),
                            Location::Danang => f.debug_tuple("Location::Danang").finish(),
                        }
                    }
                }

                impl Location {
                    pub(crate) unsafe fn _lift(val: u8) -> Location {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => Location::Hochiminh,
                            1 => Location::Hanoi,
                            2 => Location::Danang,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[derive(Clone)]
                pub struct OrderDto {
                    pub id: Id,
                    pub order_source: OrderSource,
                    pub loyalty_member_id: Id,
                    pub order_status: OrderStatus,
                    pub location: Location,
                    pub item_lines: _rt::Vec<OrderItemLineDto>,
                }
                impl ::core::fmt::Debug for OrderDto {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("OrderDto")
                            .field("id", &self.id)
                            .field("order-source", &self.order_source)
                            .field("loyalty-member-id", &self.loyalty_member_id)
                            .field("order-status", &self.order_status)
                            .field("location", &self.location)
                            .field("item-lines", &self.item_lines)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum CommandType {
                    PlaceOrder,
                }
                impl ::core::fmt::Debug for CommandType {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            CommandType::PlaceOrder => {
                                f.debug_tuple("CommandType::PlaceOrder").finish()
                            }
                        }
                    }
                }

                impl CommandType {
                    pub(crate) unsafe fn _lift(val: u8) -> CommandType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => CommandType::PlaceOrder,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[derive(Clone)]
                pub struct PlaceOrderCommand {
                    pub id: Id,
                    pub command_type: CommandType,
                    pub order_source: OrderSource,
                    pub location: Location,
                    pub loyalty_member_id: Id,
                    pub barista_items: Option<_rt::Vec<CommandItem>>,
                    pub kitchen_items: Option<_rt::Vec<CommandItem>>,
                    pub timestamp: u64,
                }
                impl ::core::fmt::Debug for PlaceOrderCommand {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("PlaceOrderCommand")
                            .field("id", &self.id)
                            .field("command-type", &self.command_type)
                            .field("order-source", &self.order_source)
                            .field("location", &self.location)
                            .field("loyalty-member-id", &self.loyalty_member_id)
                            .field("barista-items", &self.barista_items)
                            .field("kitchen-items", &self.kitchen_items)
                            .field("timestamp", &self.timestamp)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_fulfillment_order_cabi<T: Guest>() -> *mut u8 {
                    let result0 = T::get_fulfillment_order();
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec8 = result0;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 32, 4);
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 32);
                        {
                            let OrderDto {
                                id: id2,
                                order_source: order_source2,
                                loyalty_member_id: loyalty_member_id2,
                                order_status: order_status2,
                                location: location2,
                                item_lines: item_lines2,
                            } = e;
                            let vec3 = (id2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *base.add(4).cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            *base.add(8).cast::<u8>() = (order_source2.clone() as i32) as u8;
                            let vec4 = (loyalty_member_id2.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base.add(16).cast::<usize>() = len4;
                            *base.add(12).cast::<*mut u8>() = ptr4.cast_mut();
                            *base.add(20).cast::<u8>() = (order_status2.clone() as i32) as u8;
                            *base.add(21).cast::<u8>() = (location2.clone() as i32) as u8;
                            let vec7 = item_lines2;
                            let len7 = vec7.len();
                            let layout7 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 12, 4);
                            let result7 = if layout7.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout7);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec7.into_iter().enumerate() {
                                let base = result7.add(i * 12);
                                {
                                    let OrderItemLineDto {
                                        item_line_id: item_line_id5,
                                        item_type: item_type5,
                                        item_status: item_status5,
                                    } = e;
                                    let vec6 = (item_line_id5.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *base.add(4).cast::<usize>() = len6;
                                    *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                    *base.add(8).cast::<u8>() = (item_type5.clone() as i32) as u8;
                                    *base.add(9).cast::<u8>() = (item_status5.clone() as i32) as u8;
                                }
                            }
                            *base.add(28).cast::<usize>() = len7;
                            *base.add(24).cast::<*mut u8>() = result7;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len8;
                    *ptr1.add(0).cast::<*mut u8>() = result8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_fulfillment_order<T: Guest>(arg0: *mut u8) {
                    let l9 = *arg0.add(0).cast::<*mut u8>();
                    let l10 = *arg0.add(4).cast::<usize>();
                    let base11 = l9;
                    let len11 = l10;
                    for i in 0..len11 {
                        let base = base11.add(i * 32);
                        {
                            let l0 = *base.add(0).cast::<*mut u8>();
                            let l1 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l0, l1, 1);
                            let l2 = *base.add(12).cast::<*mut u8>();
                            let l3 = *base.add(16).cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l6 = *base.add(24).cast::<*mut u8>();
                            let l7 = *base.add(28).cast::<usize>();
                            let base8 = l6;
                            let len8 = l7;
                            for i in 0..len8 {
                                let base = base8.add(i * 12);
                                {
                                    let l4 = *base.add(0).cast::<*mut u8>();
                                    let l5 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                            _rt::cabi_dealloc(base8, len8 * 12, 4);
                        }
                    }
                    _rt::cabi_dealloc(base11, len11 * 32, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_place_order_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                    arg7: i32,
                    arg8: *mut u8,
                    arg9: usize,
                    arg10: i32,
                    arg11: *mut u8,
                    arg12: usize,
                    arg13: i64,
                ) -> i32 {
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg6;
                    let bytes1 = _rt::Vec::from_raw_parts(arg5.cast(), len1, len1);
                    let result6 = T::place_order(PlaceOrderCommand {
                        id: _rt::string_lift(bytes0),
                        command_type: CommandType::_lift(arg2 as u8),
                        order_source: OrderSource::_lift(arg3 as u8),
                        location: Location::_lift(arg4 as u8),
                        loyalty_member_id: _rt::string_lift(bytes1),
                        barista_items: match arg7 {
                            0 => None,
                            1 => {
                                let e = {
                                    let base3 = arg8;
                                    let len3 = arg9;
                                    let mut result3 = _rt::Vec::with_capacity(len3);
                                    for i in 0..len3 {
                                        let base = base3.add(i * 1);
                                        let e3 = {
                                            let l2 = i32::from(*base.add(0).cast::<u8>());

                                            CommandItem {
                                                item_type: ItemType::_lift(l2 as u8),
                                            }
                                        };
                                        result3.push(e3);
                                    }
                                    _rt::cabi_dealloc(base3, len3 * 1, 1);

                                    result3
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        kitchen_items: match arg10 {
                            0 => None,
                            1 => {
                                let e = {
                                    let base5 = arg11;
                                    let len5 = arg12;
                                    let mut result5 = _rt::Vec::with_capacity(len5);
                                    for i in 0..len5 {
                                        let base = base5.add(i * 1);
                                        let e5 = {
                                            let l4 = i32::from(*base.add(0).cast::<u8>());

                                            CommandItem {
                                                item_type: ItemType::_lift(l4 as u8),
                                            }
                                        };
                                        result5.push(e5);
                                    }
                                    _rt::cabi_dealloc(base5, len5 * 1, 1);

                                    result5
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        timestamp: arg13 as u64,
                    });
                    match result6 {
                        true => 1,
                        false => 0,
                    }
                }
                pub trait Guest {
                    fn get_fulfillment_order() -> _rt::Vec<OrderDto>;
                    fn place_order(command: PlaceOrderCommand) -> bool;
                }
                #[doc(hidden)]

                macro_rules! __export_coffeeshop_counter_api_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[export_name = "coffeeshop:counter/api#get-fulfillment-order"]
        unsafe extern "C" fn export_get_fulfillment_order() -> *mut u8 {
          $($path_to_types)*::_export_get_fulfillment_order_cabi::<$ty>()
        }
        #[export_name = "cabi_post_coffeeshop:counter/api#get-fulfillment-order"]
        unsafe extern "C" fn _post_return_get_fulfillment_order(arg0: *mut u8,) {
          $($path_to_types)*::__post_return_get_fulfillment_order::<$ty>(arg0)
        }
        #[export_name = "coffeeshop:counter/api#place-order"]
        unsafe extern "C" fn export_place_order(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: *mut u8,arg6: usize,arg7: i32,arg8: *mut u8,arg9: usize,arg10: i32,arg11: *mut u8,arg12: usize,arg13: i64,) -> i32 {
          $($path_to_types)*::_export_place_order_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
        }
      };);
    }
                #[doc(hidden)]
                pub(crate) use __export_coffeeshop_counter_api_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::coffeeshop::counter::api::__export_coffeeshop_counter_api_cabi!($ty with_types_in $($path_to_types_root)*::exports::coffeeshop::counter::api);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:core:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 929] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa6\x06\x01A\x02\x01\
A\x02\x01B\x1e\x01s\x04\0\x02id\x03\0\0\x01m\x0a\x0acappuccino\x0ccoffee-black\x10\
coffee-with-room\x08espresso\x0fespresso-double\x05latte\x07cakepop\x09croissant\
\x06muffin\x13croissant-chocolate\x04\0\x09item-type\x03\0\x02\x01r\x01\x09item-\
type\x03\x04\0\x0ccommand-item\x03\0\x04\x01m\x03\x06placed\x0bin-progress\x09fu\
lfilled\x04\0\x0bitem-status\x03\0\x06\x01r\x03\x0citem-line-id\x01\x09item-type\
\x03\x0bitem-status\x07\x04\0\x13order-item-line-dto\x03\0\x08\x01m\x02\x07count\
er\x03web\x04\0\x0corder-source\x03\0\x0a\x01m\x03\x06placed\x0bin-progress\x09f\
ulfilled\x04\0\x0corder-status\x03\0\x0c\x01m\x03\x09hochiminh\x05hanoi\x06danan\
g\x04\0\x08location\x03\0\x0e\x01p\x09\x01r\x06\x02id\x01\x0corder-source\x0b\x11\
loyalty-member-id\x01\x0corder-status\x0d\x08location\x0f\x0aitem-lines\x10\x04\0\
\x09order-dto\x03\0\x11\x01m\x01\x0bplace-order\x04\0\x0ccommand-type\x03\0\x13\x01\
p\x05\x01k\x15\x01r\x08\x02id\x01\x0ccommand-type\x14\x0corder-source\x0b\x08loc\
ation\x0f\x11loyalty-member-id\x01\x0dbarista-items\x16\x0dkitchen-items\x16\x09\
timestampw\x04\0\x13place-order-command\x03\0\x17\x01p\x12\x01@\0\0\x19\x04\0\x15\
get-fulfillment-order\x01\x1a\x01@\x01\x07command\x18\0\x7f\x04\0\x0bplace-order\
\x01\x1b\x04\x01\x16coffeeshop:counter/api\x05\0\x04\x01\x17coffeeshop:counter/c\
ore\x04\0\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
wit-component\x070.201.0\x10wit-bindgen-rust\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
