// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
//   * additional derives ["serde::Serialize", "serde::Deserialize"]
pub mod coffeeshop {
    pub mod counter {
        #[allow(clippy::all)]
        pub mod api {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Id = _rt::String;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum ItemType {
                /// Beverages
                Cappuccino,
                CoffeeBlack,
                CoffeeWithRoom,
                Espresso,
                EspressoDouble,
                Latte,
                /// Food
                Cakepop,
                Croissant,
                Muffin,
                CroissantChocolate,
            }
            impl ::core::fmt::Debug for ItemType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        ItemType::Cappuccino => f.debug_tuple("ItemType::Cappuccino").finish(),
                        ItemType::CoffeeBlack => f.debug_tuple("ItemType::CoffeeBlack").finish(),
                        ItemType::CoffeeWithRoom => {
                            f.debug_tuple("ItemType::CoffeeWithRoom").finish()
                        }
                        ItemType::Espresso => f.debug_tuple("ItemType::Espresso").finish(),
                        ItemType::EspressoDouble => {
                            f.debug_tuple("ItemType::EspressoDouble").finish()
                        }
                        ItemType::Latte => f.debug_tuple("ItemType::Latte").finish(),
                        ItemType::Cakepop => f.debug_tuple("ItemType::Cakepop").finish(),
                        ItemType::Croissant => f.debug_tuple("ItemType::Croissant").finish(),
                        ItemType::Muffin => f.debug_tuple("ItemType::Muffin").finish(),
                        ItemType::CroissantChocolate => {
                            f.debug_tuple("ItemType::CroissantChocolate").finish()
                        }
                    }
                }
            }

            impl ItemType {
                pub(crate) unsafe fn _lift(val: u8) -> ItemType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ItemType::Cappuccino,
                        1 => ItemType::CoffeeBlack,
                        2 => ItemType::CoffeeWithRoom,
                        3 => ItemType::Espresso,
                        4 => ItemType::EspressoDouble,
                        5 => ItemType::Latte,
                        6 => ItemType::Cakepop,
                        7 => ItemType::Croissant,
                        8 => ItemType::Muffin,
                        9 => ItemType::CroissantChocolate,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(C)]
            #[derive(Clone, Copy, serde::Deserialize, serde::Serialize)]
            pub struct CommandItem {
                pub item_type: ItemType,
            }
            impl ::core::fmt::Debug for CommandItem {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("CommandItem")
                        .field("item-type", &self.item_type)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum ItemStatus {
                Placed,
                InProgress,
                Fulfilled,
            }
            impl ::core::fmt::Debug for ItemStatus {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        ItemStatus::Placed => f.debug_tuple("ItemStatus::Placed").finish(),
                        ItemStatus::InProgress => f.debug_tuple("ItemStatus::InProgress").finish(),
                        ItemStatus::Fulfilled => f.debug_tuple("ItemStatus::Fulfilled").finish(),
                    }
                }
            }

            impl ItemStatus {
                pub(crate) unsafe fn _lift(val: u8) -> ItemStatus {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ItemStatus::Placed,
                        1 => ItemStatus::InProgress,
                        2 => ItemStatus::Fulfilled,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct OrderItemLineDto {
                pub item_line_id: Id,
                pub item_type: ItemType,
                pub item_status: ItemStatus,
            }
            impl ::core::fmt::Debug for OrderItemLineDto {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("OrderItemLineDto")
                        .field("item-line-id", &self.item_line_id)
                        .field("item-type", &self.item_type)
                        .field("item-status", &self.item_status)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum OrderSource {
                Counter,
                Web,
            }
            impl ::core::fmt::Debug for OrderSource {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        OrderSource::Counter => f.debug_tuple("OrderSource::Counter").finish(),
                        OrderSource::Web => f.debug_tuple("OrderSource::Web").finish(),
                    }
                }
            }

            impl OrderSource {
                pub(crate) unsafe fn _lift(val: u8) -> OrderSource {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => OrderSource::Counter,
                        1 => OrderSource::Web,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum OrderStatus {
                Placed,
                InProgress,
                Fulfilled,
            }
            impl ::core::fmt::Debug for OrderStatus {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        OrderStatus::Placed => f.debug_tuple("OrderStatus::Placed").finish(),
                        OrderStatus::InProgress => {
                            f.debug_tuple("OrderStatus::InProgress").finish()
                        }
                        OrderStatus::Fulfilled => f.debug_tuple("OrderStatus::Fulfilled").finish(),
                    }
                }
            }

            impl OrderStatus {
                pub(crate) unsafe fn _lift(val: u8) -> OrderStatus {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => OrderStatus::Placed,
                        1 => OrderStatus::InProgress,
                        2 => OrderStatus::Fulfilled,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum Location {
                Hochiminh,
                Hanoi,
                Danang,
            }
            impl ::core::fmt::Debug for Location {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Location::Hochiminh => f.debug_tuple("Location::Hochiminh").finish(),
                        Location::Hanoi => f.debug_tuple("Location::Hanoi").finish(),
                        Location::Danang => f.debug_tuple("Location::Danang").finish(),
                    }
                }
            }

            impl Location {
                pub(crate) unsafe fn _lift(val: u8) -> Location {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => Location::Hochiminh,
                        1 => Location::Hanoi,
                        2 => Location::Danang,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct OrderDto {
                pub id: Id,
                pub order_source: OrderSource,
                pub loyalty_member_id: Id,
                pub order_status: OrderStatus,
                pub location: Location,
                pub item_lines: _rt::Vec<OrderItemLineDto>,
            }
            impl ::core::fmt::Debug for OrderDto {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("OrderDto")
                        .field("id", &self.id)
                        .field("order-source", &self.order_source)
                        .field("loyalty-member-id", &self.loyalty_member_id)
                        .field("order-status", &self.order_status)
                        .field("location", &self.location)
                        .field("item-lines", &self.item_lines)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum CommandType {
                PlaceOrder,
            }
            impl ::core::fmt::Debug for CommandType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        CommandType::PlaceOrder => {
                            f.debug_tuple("CommandType::PlaceOrder").finish()
                        }
                    }
                }
            }

            impl CommandType {
                pub(crate) unsafe fn _lift(val: u8) -> CommandType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => CommandType::PlaceOrder,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct PlaceOrderCommand {
                pub id: Id,
                pub command_type: CommandType,
                pub order_source: OrderSource,
                pub location: Location,
                pub loyalty_member_id: Id,
                pub barista_items: Option<_rt::Vec<CommandItem>>,
                pub kitchen_items: Option<_rt::Vec<CommandItem>>,
                pub timestamp: u64,
            }
            impl ::core::fmt::Debug for PlaceOrderCommand {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("PlaceOrderCommand")
                        .field("id", &self.id)
                        .field("command-type", &self.command_type)
                        .field("order-source", &self.order_source)
                        .field("location", &self.location)
                        .field("loyalty-member-id", &self.loyalty_member_id)
                        .field("barista-items", &self.barista_items)
                        .field("kitchen-items", &self.kitchen_items)
                        .field("timestamp", &self.timestamp)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_fulfillment_order() -> _rt::Vec<OrderDto> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "coffeeshop:counter/api")]
                    extern "C" {
                        #[link_name = "get-fulfillment-order"]
                        fn wit_import(_: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base20 = l1;
                    let len20 = l2;
                    let mut result20 = _rt::Vec::with_capacity(len20);
                    for i in 0..len20 {
                        let base = base20.add(i * 32);
                        let e20 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = i32::from(*base.add(8).cast::<u8>());
                            let l7 = *base.add(12).cast::<*mut u8>();
                            let l8 = *base.add(16).cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            let l10 = i32::from(*base.add(20).cast::<u8>());
                            let l11 = i32::from(*base.add(21).cast::<u8>());
                            let l12 = *base.add(24).cast::<*mut u8>();
                            let l13 = *base.add(28).cast::<usize>();
                            let base19 = l12;
                            let len19 = l13;
                            let mut result19 = _rt::Vec::with_capacity(len19);
                            for i in 0..len19 {
                                let base = base19.add(i * 12);
                                let e19 = {
                                    let l14 = *base.add(0).cast::<*mut u8>();
                                    let l15 = *base.add(4).cast::<usize>();
                                    let len16 = l15;
                                    let bytes16 =
                                        _rt::Vec::from_raw_parts(l14.cast(), len16, len16);
                                    let l17 = i32::from(*base.add(8).cast::<u8>());
                                    let l18 = i32::from(*base.add(9).cast::<u8>());

                                    OrderItemLineDto {
                                        item_line_id: _rt::string_lift(bytes16),
                                        item_type: ItemType::_lift(l17 as u8),
                                        item_status: ItemStatus::_lift(l18 as u8),
                                    }
                                };
                                result19.push(e19);
                            }
                            _rt::cabi_dealloc(base19, len19 * 12, 4);

                            OrderDto {
                                id: _rt::string_lift(bytes5),
                                order_source: OrderSource::_lift(l6 as u8),
                                loyalty_member_id: _rt::string_lift(bytes9),
                                order_status: OrderStatus::_lift(l10 as u8),
                                location: Location::_lift(l11 as u8),
                                item_lines: result19,
                            }
                        };
                        result20.push(e20);
                    }
                    _rt::cabi_dealloc(base20, len20 * 32, 4);
                    result20
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn place_order(command: &PlaceOrderCommand) -> bool {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let PlaceOrderCommand {
                        id: id0,
                        command_type: command_type0,
                        order_source: order_source0,
                        location: location0,
                        loyalty_member_id: loyalty_member_id0,
                        barista_items: barista_items0,
                        kitchen_items: kitchen_items0,
                        timestamp: timestamp0,
                    } = command;
                    let vec1 = id0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = loyalty_member_id0;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let (result5_0, result5_1, result5_2) = match barista_items0 {
                        Some(e) => {
                            let vec4 = e;
                            let len4 = vec4.len();
                            let layout4 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec4.len() * 1, 1);
                            let result4 = if layout4.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout4);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec4.into_iter().enumerate() {
                                let base = result4.add(i * 1);
                                {
                                    let CommandItem {
                                        item_type: item_type3,
                                    } = e;
                                    *base.add(0).cast::<u8>() = (item_type3.clone() as i32) as u8;
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result4, layout4)]);

                            (1i32, result4, len4)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let (result8_0, result8_1, result8_2) = match kitchen_items0 {
                        Some(e) => {
                            let vec7 = e;
                            let len7 = vec7.len();
                            let layout7 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 1, 1);
                            let result7 = if layout7.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout7);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec7.into_iter().enumerate() {
                                let base = result7.add(i * 1);
                                {
                                    let CommandItem {
                                        item_type: item_type6,
                                    } = e;
                                    *base.add(0).cast::<u8>() = (item_type6.clone() as i32) as u8;
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result7, layout7)]);

                            (1i32, result7, len7)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "coffeeshop:counter/api")]
                    extern "C" {
                        #[link_name = "place-order"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                        ) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        ptr1.cast_mut(),
                        len1,
                        command_type0.clone() as i32,
                        order_source0.clone() as i32,
                        location0.clone() as i32,
                        ptr2.cast_mut(),
                        len2,
                        result5_0,
                        result5_1,
                        result5_2,
                        result8_0,
                        result8_1,
                        result8_2,
                        _rt::as_i64(timestamp0),
                    );
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    _rt::bool_lift(ret as u8)
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub use alloc_crate::alloc;

    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }

    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }

    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }

    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            ::core::mem::transmute::<u8, bool>(val)
        }
    }
    extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:host:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 929] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa6\x06\x01A\x02\x01\
A\x02\x01B\x1e\x01s\x04\0\x02id\x03\0\0\x01m\x0a\x0acappuccino\x0ccoffee-black\x10\
coffee-with-room\x08espresso\x0fespresso-double\x05latte\x07cakepop\x09croissant\
\x06muffin\x13croissant-chocolate\x04\0\x09item-type\x03\0\x02\x01r\x01\x09item-\
type\x03\x04\0\x0ccommand-item\x03\0\x04\x01m\x03\x06placed\x0bin-progress\x09fu\
lfilled\x04\0\x0bitem-status\x03\0\x06\x01r\x03\x0citem-line-id\x01\x09item-type\
\x03\x0bitem-status\x07\x04\0\x13order-item-line-dto\x03\0\x08\x01m\x02\x07count\
er\x03web\x04\0\x0corder-source\x03\0\x0a\x01m\x03\x06placed\x0bin-progress\x09f\
ulfilled\x04\0\x0corder-status\x03\0\x0c\x01m\x03\x09hochiminh\x05hanoi\x06danan\
g\x04\0\x08location\x03\0\x0e\x01p\x09\x01r\x06\x02id\x01\x0corder-source\x0b\x11\
loyalty-member-id\x01\x0corder-status\x0d\x08location\x0f\x0aitem-lines\x10\x04\0\
\x09order-dto\x03\0\x11\x01m\x01\x0bplace-order\x04\0\x0ccommand-type\x03\0\x13\x01\
p\x05\x01k\x15\x01r\x08\x02id\x01\x0ccommand-type\x14\x0corder-source\x0b\x08loc\
ation\x0f\x11loyalty-member-id\x01\x0dbarista-items\x16\x0dkitchen-items\x16\x09\
timestampw\x04\0\x13place-order-command\x03\0\x17\x01p\x12\x01@\0\0\x19\x04\0\x15\
get-fulfillment-order\x01\x1a\x01@\x01\x07command\x18\0\x7f\x04\0\x0bplace-order\
\x01\x1b\x03\x01\x16coffeeshop:counter/api\x05\0\x04\x01\x17coffeeshop:counter/h\
ost\x04\0\x0b\x0a\x01\0\x04host\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
wit-component\x070.201.0\x10wit-bindgen-rust\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
