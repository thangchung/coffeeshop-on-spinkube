// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
//   * additional derives ["serde::Serialize", "serde::Deserialize"]
pub mod example {
    pub mod coffeeshop {
        #[allow(clippy::all)]
        pub mod product_api {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
            pub enum ItemType {
                /// Beverages
                Cappuccino,
                CoffeeBlack,
                CoffeeWithRoom,
                Espresso,
                EspressoDouble,
                Latte,
                /// Food
                Cakepop,
                Croissant,
                Muffin,
                CroissantChocolate,
            }
            impl ::core::fmt::Debug for ItemType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        ItemType::Cappuccino => f.debug_tuple("ItemType::Cappuccino").finish(),
                        ItemType::CoffeeBlack => f.debug_tuple("ItemType::CoffeeBlack").finish(),
                        ItemType::CoffeeWithRoom => {
                            f.debug_tuple("ItemType::CoffeeWithRoom").finish()
                        }
                        ItemType::Espresso => f.debug_tuple("ItemType::Espresso").finish(),
                        ItemType::EspressoDouble => {
                            f.debug_tuple("ItemType::EspressoDouble").finish()
                        }
                        ItemType::Latte => f.debug_tuple("ItemType::Latte").finish(),
                        ItemType::Cakepop => f.debug_tuple("ItemType::Cakepop").finish(),
                        ItemType::Croissant => f.debug_tuple("ItemType::Croissant").finish(),
                        ItemType::Muffin => f.debug_tuple("ItemType::Muffin").finish(),
                        ItemType::CroissantChocolate => {
                            f.debug_tuple("ItemType::CroissantChocolate").finish()
                        }
                    }
                }
            }

            impl ItemType {
                pub(crate) unsafe fn _lift(val: u8) -> ItemType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ItemType::Cappuccino,
                        1 => ItemType::CoffeeBlack,
                        2 => ItemType::CoffeeWithRoom,
                        3 => ItemType::Espresso,
                        4 => ItemType::EspressoDouble,
                        5 => ItemType::Latte,
                        6 => ItemType::Cakepop,
                        7 => ItemType::Croissant,
                        8 => ItemType::Muffin,
                        9 => ItemType::CroissantChocolate,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ItemTypeModel {
                pub name: _rt::String,
                pub item_type: ItemType,
                pub price: f32,
                pub image: _rt::String,
            }
            impl ::core::fmt::Debug for ItemTypeModel {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("ItemTypeModel")
                        .field("name", &self.name)
                        .field("item-type", &self.item_type)
                        .field("price", &self.price)
                        .field("image", &self.image)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_item_types() -> _rt::Vec<ItemTypeModel> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "example:coffeeshop/product-api")]
                    extern "C" {
                        #[link_name = "get-item-types"]
                        fn wit_import(_: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base11 = l1;
                    let len11 = l2;
                    let mut result11 = _rt::Vec::with_capacity(len11);
                    for i in 0..len11 {
                        let base = base11.add(i * 24);
                        let e11 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = i32::from(*base.add(8).cast::<u8>());
                            let l7 = *base.add(12).cast::<f32>();
                            let l8 = *base.add(16).cast::<*mut u8>();
                            let l9 = *base.add(20).cast::<usize>();
                            let len10 = l9;
                            let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                            ItemTypeModel {
                                name: _rt::string_lift(bytes5),
                                item_type: ItemType::_lift(l6 as u8),
                                price: l7,
                                image: _rt::string_lift(bytes10),
                            }
                        };
                        result11.push(e11);
                    }
                    _rt::cabi_dealloc(base11, len11 * 24, 4);
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_item_by_types(types: &[_rt::String]) -> _rt::Vec<ItemTypeModel> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec1 = types;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
                    let result1 = if layout1.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout1);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec1.into_iter().enumerate() {
                        let base = result1.add(i * 8);
                        {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            *base.add(4).cast::<usize>() = len0;
                            *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                        }
                    }
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "example:coffeeshop/product-api")]
                    extern "C" {
                        #[link_name = "get-item-by-types"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(result1, len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let base13 = l3;
                    let len13 = l4;
                    let mut result13 = _rt::Vec::with_capacity(len13);
                    for i in 0..len13 {
                        let base = base13.add(i * 24);
                        let e13 = {
                            let l5 = *base.add(0).cast::<*mut u8>();
                            let l6 = *base.add(4).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                            let l8 = i32::from(*base.add(8).cast::<u8>());
                            let l9 = *base.add(12).cast::<f32>();
                            let l10 = *base.add(16).cast::<*mut u8>();
                            let l11 = *base.add(20).cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                            ItemTypeModel {
                                name: _rt::string_lift(bytes7),
                                item_type: ItemType::_lift(l8 as u8),
                                price: l9,
                                image: _rt::string_lift(bytes12),
                            }
                        };
                        result13.push(e13);
                    }
                    _rt::cabi_dealloc(base13, len13 * 24, 4);
                    if layout1.size() != 0 {
                        _rt::alloc::dealloc(result1.cast(), layout1);
                    }
                    result13
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:product-host:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 465] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xce\x02\x01A\x02\x01\
A\x02\x01B\x0a\x01m\x0a\x0acappuccino\x0ccoffee-black\x10coffee-with-room\x08esp\
resso\x0fespresso-double\x05latte\x07cakepop\x09croissant\x06muffin\x13croissant\
-chocolate\x04\0\x09item-type\x03\0\0\x01r\x04\x04names\x09item-type\x01\x05pric\
ev\x05images\x04\0\x0fitem-type-model\x03\0\x02\x01p\x03\x01@\0\0\x04\x04\0\x0eg\
et-item-types\x01\x05\x01ps\x01@\x01\x05types\x06\0\x04\x04\0\x11get-item-by-typ\
es\x01\x07\x03\x01\x1eexample:coffeeshop/product-api\x05\0\x04\x01\x1fexample:co\
ffeeshop/product-host\x04\0\x0b\x12\x01\0\x0cproduct-host\x03\0\0\0G\x09producer\
s\x01\x0cprocessed-by\x02\x0dwit-component\x070.201.0\x10wit-bindgen-rust\x060.2\
1.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
